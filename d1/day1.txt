
day 1 of parallel C++:
======================			

C/C++ (Phase II)
----------------

			program
			|
			|---> pre-processing
			|
			V
			Source
		    /   |
	       assembly |---> compilation (declarations)
		    \   |
			V
			Object file
			|
			|---> linking (definitions)
			|
			V
			Executable


	int x; 		// declaration
	int x = 100;	// definition

	// when you use extern keyword, its declaration only:
	extern int x;	// declaration only

	// This is because, compiler has something called:
	// ODR = One Definition Rule.

==========================================================================

What is pre-processing?
	
	instructions to pre-processor
		OR
	preprocessor directives

	in C/C++ any statements starting with "#" is a preprocessor directive.
	in line: "#include <stdio.h>",
	include is the directive and stdio.h is the argument.

	what "include" does is include the contents of header file into our current program.
	please note that <> is for system headers and "" is for user defined headers.
	This is done to optimize the searching of header files when the preprocessor runs.
	
	Linux has a directories called:
	/include
	and 
	/usr/include

	When you use <>, your preprocessor knows to search in these directories,
	for system header files. 

	When you use "", your preprocessor searches for header files in,
	current working directory.

	This is how searching for header files is optimized.

	#include<> helps include the declarations into your program.

	Inorder to tell compiler to include certain header files in some directory,
	we can use -I option while compiling our program.
	syntax:
	$gcc -I directory_path filename.c
	for eg:
	if your header files are in current working directory, then use:
	$gcc -I . filename.c

	Then you can use user defined headerfiles with <>.

	Other pre-processor directives:
	
	#define
	#ifndef
	#endif
	#if
	#else

===========================================================================

for only seeing compilation errors, using "-c" option while compiling:
gcc program2Main.c -c

This helps you avoid viewing the linker errors, only compilation errors are displayed.
This also creates an object file. Using these object files you can also create executable files.


Similarly we can use options like:

"-E" for pre-processing only
"-S" for generating assembly code.


For now we can do this to generate an object file:
gcc program2Main.c -c

and this to generate executable file from object file:
gcc -o myout program2Main.o programTwo.c


for analyzing object/executable files, use these commands and options:
use:
->od			// octal dump
see:
https://man7.org/linux/man-pages/man1/od.1.html

->hexdump		// hexadecimal dump
see: 
https://en.wikipedia.org/wiki/Hex_dump
https://man7.org/linux/man-pages/man1/hexdump.1.html

->xxd			
see:
https://linux.die.net/man/1/xxd
 
->objdump		// object dump
see:
https://man7.org/linux/man-pages/man1/objdump.1.html


================================================================

Detailed discussion on how we can shift declarations into header files.
and also we can shift function definitions into other files and
main function in a separate file.
Later, when we compile, we mention all files and they are linked together using linker.

================================================================

In C++,
even in case of classes, 
we can separate declaration, usage and definitions into separate files.
i.e.: 
preprocessors and all class member declarations in a header file.
main function in other file.
class member definitions (using scope resolution operator) in other file.

In C++ terminology:
declaration = abstraction
definition = usage

see folder withClass for more details.

compile the main file to create an object file using:
g++ Main.cpp -c

then create an executable using:
g++ -o exec Main.o encapsulation.cpp

================================================================

Instead of typing all files which have function definition,
we can bundle all these files in a "archive". 

This is similar to jar files in java.

use the following command to archive all files which have definitions:
$ar -q mylib.a fun.o fun1.o fun2.o ....

After this an archive file called "mylib.a",
in windows we call it lib files or static library files.
in linux we call it archive files.

Other options:
-a = append
-d 
-r = replace

there are many more options, use "man ar" to learn more.


Finally, when you create an executable instead of using:
$g++ -o exec Main.o -I . encapsulation1.o encapsulation2.o ... encapsulationn.o
we will use:
$g++ -o exec Main.o -I . mylib.a
to create an executable file.

to summarize, after creating all files, run the following commands:

$g++ Main.cpp -c
$g++ Encapsulation1.cpp -c
...
$g++ Encapsulationn.cpp -c
$ar -q encapArchive.a Encapsulation1.o Encapsulation2.o ... Encapsulation3.o
$g++ -o executablefilename Main.o -I . encapArchive.a

================================================================

This multi file approach for storing cpp programs is used in the industry.

The general folder structure of a cpp project is as follows:
"src"		// all c/c++ code is stored here
"include"	// all header files stored here
"bin"		// all executables aka binaries are stored here
"lib"		// object files stored here (archive files like .a files are also stored here)
"doc"		// all documentation is stored here

================================================================
















